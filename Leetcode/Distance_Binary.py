# -*- coding: utf-8 -*-
"""
Spyder Editor
给定一个正整数 N，找到并返回 N 的二进制表示中两个连续的 1 之间的最长距离。 
如果没有两个连续的 1，返回 0

结题思路1
由于我们想要检查数字 N 的二进制表示法中连续的 1 之间的距离，
让我们先记录下该二进制表示中每个 1 的索引。例如，如果 N = 22 = 0b10110，
那么我们将记录 A = [1, 2, 4]。
这使得我们可以容易地继续，原问题被转换为关于数组中相邻值的问题。

eq
输入：22
输出：2
解释：
22 的二进制是 0b10110 。
在 22 的二进制表示中，有三个 1，组成两对连续的 1 。
第一对连续的 1 中，两个 1 之间的距离为 2 。
第二对连续的 1 中，两个 1 之间的距离为 1 。
答案取两个距离之中最大的，也就是 2 

结题思路2
我们将存储 last，这是被添加到虚拟数组 A 中的最后一个值。
如果 N 的第 i 位（此处应当有索引 last < i ）为 1，那么一个候选答案就是 i - last，
然后新增到 A 的最后一个值被更新为 i，即 last = i
This is a temporary script file.
"""

class Solution(object):
    def binaryGap(self, N):
        num = 0    #初始化计数值n
        A = [i for i in range(32) if (N >> i) & 1]
        #A提前申请了一个32字节的存储空间，循环右移判断如果是1就输出这个位置的标号
        if len(A) < 2:     #异常值处理
            return 0
        for i in range(len(A) - 1):  #循环，如果前一个和后一个标号相差1说明挨着
            if A[i + 1] - A[i] == 1:
                num +=1        
        return num+1                 #减完出来是少一个数的，要补1
a=Solution()
print(a.binaryGap(15))